from .proc import run_process as _run_process
import json as _json

def strip_comments(code):
    lines = code.split('\n')
    output = []
    for original_line in lines:
        line = original_line.strip()
        if line == '': continue
        if line.startswith('//'): continue
        output.append(original_line)
    return '\n'.join(output) + '\n'

# Deprecate this.
def simple_minify(code):
    code = strip_comments(code).strip()
    lines = list(map(lambda line: line.strip(), code.split('\n')))
    output = [lines[0]]
    for line in lines[1:]:
        append_to_last = False
        if len(output) > 0:
            first_char = line[0]
            prev_char = output[-1][-1]
            if prev_char in ';{([,/+-.<>': append_to_last = True
            if first_char in ';})],.<>': append_to_last = True
            if len(output[-1]) > 300: append_to_last = False

        if not append_to_last:
            output.append('\n')
        output.append(line)
    output.append('\n')
    return ''.join(output)

def minify(path):
    output = _run_process('terser', [path, '--compress', '--mangle'])
    return output

# TODO: the interleaved approach has quite a bit of potential to save even more space
# but requires quite a bit of tweaking. The sequences should be automatically detected and
# use some of the unicode sequences used in the previous pre-interleaving iteration.
def minify_plus(path):
    original_code = minify(path)

    # Use unicode characters that are 2 bytes in UTF-8 to represent longer sequences
    # of characters. Wrap the code in a string and replace them.
    # After the code has been minified, split the sequence into two interleaved sequences
    # and perform the same process with different sequences.
    # This is because there are many patterns in every other character in minified code,
    # particularly when the code is generated by Pastel or terser.
    # e.g. (a,b,c,d) will create common sequences of (,,,)

    two_byte_chars = 'À Á Â Ã Ä Å Æ Ç È Ê Ë Ì Í Î Ï Ð Ñ Ò Ó Ô Õ Ö Ø Ù Ú Û Ü Ý Þ ß à á â ã ä å æ ç'.split(' ')[::-1]
    two_byte_chars = list(filter(lambda c: c not in original_code, two_byte_chars))
    sequences = [
        '\\', # Some issues with escape sequences being swapped back in
        '`', # Whole final string is wrapped in backticks.
        '${', # Prevent accidental templates

        '=function(',
        'function(',
        'Object.keys',
        'null',
        'return',
        'continue',
        'break',
        'switch',
        'case',
        '.length',
        '.join("',
        'let ',
        ';for(',
        #'][0]',
        'new ',
        'void 0!==',
        '.push(',
        'throw new Error(',
        ';if(',
        'Exception',
    ]

    split_phase_sequences = [
        ',,,,,',
        ',[]',
        '=,=',
        ',,,',
        '(,,)',
        '(,,',
        '(,)',
        '[],',
        ';; :',
        ';; ',
        '[][]',
    ]

    if len(sequences) + len(split_phase_sequences) > len(two_byte_chars):
        raise Exception()

    swaps = []
    code = original_code
    lookup = {}
    for seq in sequences:
        if '#' in seq: raise Exception() # used as a delimiter later
        if seq in code:
            c = two_byte_chars.pop()
            swaps.append((c, seq))
            lookup[c] = seq
            code = code.replace(seq, c)

    final_code = code
    roundtrip_verify = []

    for c in final_code:
        roundtrip_verify.append(lookup.get(c, c))
    roundtrip_verify_flat = ''.join(roundtrip_verify)

    if roundtrip_verify_flat != original_code:
        raise Exception()

    swap_lookup = []
    for swap in swaps:
        swap_lookup.append(swap[0])
        swap_lookup.append(swap[1])

    phases = [
        final_code[0::2],
        final_code[1::2]
    ]

    swap_lookup_split_phase = []
    for seq in split_phase_sequences:
        if seq in phases[0] or seq in phases[1]:
            c = two_byte_chars.pop()
            for i in range(2):
                phases[i] = phases[i].replace(seq, c)
            swap_lookup_split_phase.append(c)
            swap_lookup_split_phase.append(seq)

    return ''.join([
        'eval(((a, b) => {',
            'let makeLookup=r=>{',
                'let w={};',
                'r = r.split("#");',
                'for(let i=0; i<r.length; i+=2){',
                    'w[r[i]]=r[i+1];',
                '}',
                'return w;',
            '};',
            'let s=makeLookup(' + _json.dumps('#'.join(swap_lookup)), ');',
            'let s2=makeLookup(' + _json.dumps('#'.join(swap_lookup_split_phase)), ');',
            'let p=(t,lu)=>{', # do swap with w lookup
                'let u="";',
                'for(let h of t.split("")) {',
                    'u+=lu[h]||h;'
                '}',
                'return u;',
            '};',
            'a=p(a,s2);',
            'b=p(b,s2);',
            'if(a.length>b.length)b+=" ";',
            'return p(a.split("").map((c,i)=>c+b[i]).join(""), s);'
        '})(`', phases[0], '`,`',phases[1],'`));\n'
    ])
