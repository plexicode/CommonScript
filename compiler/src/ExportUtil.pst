
Array<int> ExportUtil_exportBundle(string flavorId, string extVersionId, CompilationBundle bundle) {

    int i = 0;
    int j = 0;

    ByteStringBuilder flavor = bsbFromLenString(flavorId);
    ByteStringBuilder version = bsbFromLenString(extVersionId);
    int commonScriptMajor = 0;
    int commonScriptMinor = 1;
    int commonScriptPatch = 0;

    ByteStringBuilder header = bsbJoin4(
        bsbFromUtf8String("PXCS"),
        bsbFrom4Bytes(
            0,
            commonScriptMajor,
            commonScriptMinor,
            commonScriptPatch),
        flavor,
        version);

    // TODO: xor-down a sha256 into a short checksum of the remaining chunks

    ByteStringBuilder metadata = bsbJoin3(
        bsbFromUtf8String("MTD"),
        bsbFromInt(bundle.mainFunctionId),
        bsbFromInt(bundle.builtInCount)
    );

    ByteStringBuilder tokenData = bsbJoin2(
        bsbFromUtf8String("TOK"),
        bsbFromInt(bundle.tokensById.size() - 1));
    Dictionary<string, int> fileNameToOffset = new Dictionary<string, int>();
    ByteStringBuilder tokenFileNames = null;
    for (i = 1; i < bundle.tokensById.size(); i += 1) {
        Token tok = bundle.tokensById[i];
        string filename = tok.File;
        if (!fileNameToOffset.contains(filename)) {
            fileNameToOffset[filename] = fileNameToOffset.size();
            tokenFileNames = bsbJoin2(tokenFileNames, bsbFromLenString(filename));
        }
    }
    tokenData = bsbJoin3(tokenData, bsbFromInt(fileNameToOffset.size()), tokenFileNames);
    for (i = 1; i < bundle.tokensById.size(); i += 1) {
        Token tok = bundle.tokensById[i];
        string filename = tok.File;
        int fileOffset = fileNameToOffset[filename];
        tokenData = bsbJoin4(tokenData, bsbFromInt(fileOffset), bsbFromInt(tok.Line), bsbFromInt(tok.Col));
    }

    ByteStringBuilder stringData = bsbJoin2(
        bsbFromUtf8String("STR"),
        bsbFromInt(bundle.stringById.size() - 1));
    for (i = 1; i < bundle.stringById.size(); i += 1) {
        string val = bundle.stringById[i];
        stringData = bsbJoin2(stringData, bsbFromLenString(val));
    }

    ByteStringBuilder entityAcc = null;

    for (i = 1; i < bundle.functionById.size(); i += 1) {
        BundleFunctionInfo fn = bundle.functionById[i];
        entityAcc = bsbJoin2(entityAcc, bsbJoin5(
            bsbFromInt(fn.argcMin),
            bsbFromInt(fn.argcMax),
            bsbFromLenString(fn.name),
            bsbFromInt(fn.code.size()),
            ExportUtil_exportCode(fn.code))
        );
    }

    for (i = 1; i < bundle.lambdaById.size(); i += 1) {
        BundleFunctionInfo fn = bundle.lambdaById[i];
        entityAcc = bsbJoin2(entityAcc, bsbJoin4(
            bsbFromInt(fn.argcMin),
            bsbFromInt(fn.argcMax),
            bsbFromInt(fn.code.size()),
            ExportUtil_exportCode(fn.code))
        );
    }

    for (i = 1; i < bundle.enumById.size(); i += 1) {
        BundleEnumInfo bei = bundle.enumById[i];
        int memberCount = bei.names.size();
        entityAcc = bsbJoin2(entityAcc, bsbFromInt(memberCount));
        for (j = 0; j < memberCount; j++) {
            entityAcc = bsbJoin3(
                entityAcc,
                bsbFromLenString(bei.names[j]),
                bsbFromInt(bei.values[j]));
        }
    }

    for (i = 1; i < bundle.classById.size(); i += 1) {
        BundleClassInfo bci = bundle.classById[i];
        ByteStringBuilder classInfo = bsbJoin8(
            bsbFromLenString(bci.name),
            bsbFromInt(bci.parentId),
            bsbFromInt(bci.ctorId),
            bsbFromInt(bci.staticCtorId),
            bsbFromInt(bci.newDirectMembersByNextOffsets.size()),
            bsbFromInt(bci.methodsToId.size()),
            bsbFromInt(bci.staticFields.size()),
            bsbFromInt(bci.staticMethods.size()));

        for (j = 0; j < bci.newDirectMembersByNextOffsets.size(); j += 1) {
            // TODO: encode function ID here instead of below
            // This also means that you'll have to indicate that a string does not contribute to the new direct member count

            string memberName = bci.newDirectMembersByNextOffsets[j];
            bool isMethod = bci.methodsToId.contains(memberName);
            int info = 0;
            if (isMethod) {
                info = 1;
                // TODO: put the function ID here once you have a way to indicate overridden methods
            } else {
                // TODO: put the field initial value here. For now, just set all this in the constructor.
            }
            classInfo = bsbJoin3(
                classInfo,
                bsbFromLenString(memberName),
                bsbFromInt(info));
        }

        ByteStringBuilder methodInfo = null;
        Array<string> methodNames = Sorting.getLexicalSortedCopy(bci.methodsToId.keys());
        for (j = 0; j < methodNames.size(); j += 1) {
            string methodName = methodNames[j];
            methodInfo = bsbJoin3(
                methodInfo,
                bsbFromLenString(methodName),
                bsbFromInt(bci.methodsToId[methodName]));
        }

        ByteStringBuilder staticFields = null;
        Array<string> fieldNames = Sorting.getLexicalSortedCopy(bci.staticFields.toArray());
        for (j = 0; j < fieldNames.size(); j += 1) {
            string staticField = fieldNames[j];
            staticFields = bsbJoin2(
                staticFields,
                bsbFromLenString(staticField));
        }

        ByteStringBuilder staticMethods = null;
        Array<string> staticMethodNames = Sorting.getLexicalSortedCopy(bci.staticMethods.toArray());
        for (j = 0; j < staticMethodNames.size(); j += 1) {
            string staticMethod = staticMethodNames[j];
            int funcId = bci.methodsToId[staticMethod];
            staticMethods = bsbJoin3(
                staticMethods,
                bsbFromLenString(staticMethod),
                bsbFromInt(funcId));
        }

        entityAcc = bsbJoin5(
            entityAcc,
            classInfo,
            methodInfo,
            staticFields,
            staticMethods);
    }

    ByteStringBuilder entityHeader = bsbJoin5(
        bsbFromUtf8String("ENT"),
        bsbFromInt(bundle.functionById.size() - 1),
        bsbFromInt(bundle.enumById.size() - 1),
        bsbFromInt(bundle.classById.size() - 1),
        bsbFromInt(bundle.lambdaById.size() - 1));

    ByteStringBuilder entityData = bsbJoin2(entityHeader, entityAcc);

    ByteStringBuilder full = bsbJoin5(
        header, metadata, stringData, tokenData, entityData);

    return bsbFlatten(full);
}

ByteStringBuilder ExportUtil_exportCode(Array<ByteCodeRow> rows) {
    ByteStringBuilder bsb = null;
    for (int i = 0; i < rows.size(); i += 1) {
        ByteCodeRow row = rows[i];
        Array<int> args = row.args;
        int argsLen = args.size();

        int flags = argsLen * 4;

        ByteStringBuilder bsbStringArg = null;
        ByteStringBuilder bsbToken = null;

        if (row.stringArg != null) {
            flags += 1;
            bsbStringArg = bsbFromInt(row.stringId);
        }

        if (row.token != null) {
            flags += 2;
            bsbToken = bsbFromInt(row.tokenId);
        }

        ByteStringBuilder bsbRow = bsbJoin4(
            bsbFromInt(row.opCode),
            bsbFromInt(flags),
            bsbStringArg,
            bsbToken);

        for (int j = 0; j < argsLen; j += 1) {
            bsbRow = bsbJoin2(bsbRow, bsbFromInt(args[j]));
        }
        bsb = bsbJoin2(bsb, bsbRow);
    }

    return bsb;
}
