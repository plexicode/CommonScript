struct StaticContext {
    TokenizerStaticContext tokenizerCtx;
    Dictionary<string, AbstractEntity> emptyLookup;
    SpecialActionUtil specialActionUtil;
    StringSet validAnnotationNames;
}

StaticContext StaticContext_new() {
    return new StaticContext(
        TokenizerStaticContext_new(),
        new Dictionary<string, AbstractEntity>(),
        SpecialActionUtil_new(),
        StringSet_fromArray("public static".split(" "))
    );
}

struct TokenizerStaticContext {
    Dictionary<int, bool> alphanumerics;
    Dictionary<int, bool> numerics;
    Dictionary<int, bool> whitespace;
    StringSet keywords;
    Dictionary<int, List<Array<int>>> multicharTokensByFirstChar;
}
TokenizerStaticContext TokenizerStaticContext_new() {
    TokenizerStaticContext ctx = new TokenizerStaticContext(
        new Dictionary<int, bool>(),
        new Dictionary<int, bool>(),
        new Dictionary<int, bool>(),
        null,
        new Dictionary<int, List<Array<int>>>());

    int i = 0;
    for (i = 0; i < 10; i += 1) {
        ctx.numerics[Convert.charToCharCode('0') + i] = true;
        ctx.alphanumerics[Convert.charToCharCode('0') + i] = true;
    }
    for (i = 0; i < 26; i += 1) {
        ctx.alphanumerics[Convert.charToCharCode('A') + i] = true;
        ctx.alphanumerics[Convert.charToCharCode('a') + i] = true;
    }
    ctx.alphanumerics[Convert.charToCharCode('_')] = true;

    string ws = " \r\n\t";
    for (i = 0; i < ws.size(); i += 1) {
        ctx.whitespace[Convert.charToCharCode(ws[i])] = true;
    }

    ctx.keywords = StringSet_fromArray("function class field property constructor const enum
base this
null false true new
is typeof
if else for while do break continue switch case default yield return
throw try catch finally
import namespace
public static readonly abstract".trim().replace("\n", " ").split(" "));

    // This list must be sorted by length descending as longer candidates must be checked
    // before shorter ones. For example, it would be a bug for >>> to register as a hit before >>>= does.
    Array<string> mcharTokens = ">>>= >>> <<= >>= **= ++ -- && || ** == != <= >= => -> << >> ?? += -= *= %= /= |= &= ^=".split(" ");
    for (i = 0; i < mcharTokens.size(); i += 1) {
        string mcharTok = mcharTokens[i];
        Array<int> uchars = new Array<int>(mcharTok.size());
        for (int j = 0; j < uchars.size(); j += 1) {
            uchars[j] = Convert.charToCharCode(mcharTok[j]);
        }
        int firstChar = uchars[0];
        if (!ctx.multicharTokensByFirstChar.contains(firstChar)) {
            ctx.multicharTokensByFirstChar[firstChar] = new List<Array<int>>();
        }
        ctx.multicharTokensByFirstChar[firstChar].add(uchars);
    }

    return ctx;
}

