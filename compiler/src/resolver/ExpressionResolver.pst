
void ExpressionResolver_ResolveExpressionArrayFirstPass(Resolver resolver, Array<Expression> arr) {
    for (int i = 0; i < arr.Size(); i += 1) {
        arr[i] = resolver.ResolveExpressionFirstPass(resolver, arr[i]);
    }
}

void ExpressionResolver_ResolveExpressionArraySecondPass(Resolver resolver, Array<Expression> arr) {
    for (int i = 0; i < arr.Size(); i += 1) {
        arr[i] = resolver.ResolveExpressionSecondPass(resolver, arr[i]);
    }
}

Expression ExpressionResolver_FirstPass_BaseCtorReference(Resolver resolver, Expression baseCtor) {
    return baseCtor;
}

Expression ExpressionResolver_FirstPass_BoolConst(Resolver resolver, Expression bc) {
    return bc;
}

Expression ExpressionResolver_FirstPass_ConstructorInvocation(Resolver resolver, Expression ctorInvoke) {
    // You left off here realizing that it's actually better to just use CONSTRUCTOR_REF as a parse node, that way
    // the resolver for the path of the item can be resolve in a normal way e.g. "new myModuleAlias.SomeClass()" should
    // resolve as an invocation of a class reference expression.
    fail("not implemented");
    return null;
}

Expression ExpressionResolver_FirstPass_FloatConstant(Resolver resolver, Expression floatConst) {
    return floatConst;
}

Expression ExpressionResolver_FirstPass_IntegerConstant(Resolver resolver, Expression intConst) {
    return intConst;
}

Expression ExpressionResolver_FirstPass_Lambda(Resolver resolver, Expression lamb) {
    int i = 0;

    // TODO: pastel should support Core.ArrayToList()
    List<Token> argNames = new List<Token>();
    for (i = 0; i < lamb.argNames.Size(); i += 1) {
        argNames.Add(lamb.argNames[i]);
    }
    List<Expression> argValues = new List<Expression>();
    for (i = 0; i < lamb.values.Size(); i += 1) {
        argValues.Add(lamb.values[i]);
    }

    List<Statement> code = new List<Statement>();
    for (i = 0; i < lamb.nestedCode.Size(); i += 1) {
        code.Add(lamb.nestedCode[i]);
    }

    FunctionEntity lambdaEnt = FunctionEntity_BuildLambda(
        resolver.activeEntity.fileContext,
        lamb.firstToken,
        argNames,
        argValues,
        code);

    Resolver_ReportNewLambda(resolver, lambdaEnt);
    lamb.entityPtr = lambdaEnt.baseData;
    return lamb;
}

Expression ExpressionResolver_FirstPass_NullConst(Resolver resolver, Expression nullConst) {
    return nullConst;
}

Expression ExpressionResolver_FirstPass_StringConstant(Resolver resolver, Expression strConst) {
    return strConst;
}

Expression ExpressionResolver_FirstPass_This(Resolver resolver, Expression thisExpr) {
    return thisExpr;
}

Expression ExpressionResolver_FirstPass_Variable(Resolver resolver, Expression varExpr) {
    string name = varExpr.strVal;

    AbstractEntity localEntity = ExpressionResolver_FindLocallyReferencedEntity(resolver.staticCtx, resolver.nestedEntities, name);
    if (localEntity != null) {
        return ExpressionResolver_WrapEntityIntoReferenceExpression(resolver, varExpr.firstToken, localEntity);
    }

    Expression importedRef = LookupUtil_DoFirstPassVariableLookupThroughImports(resolver, varExpr.firstToken, name);
    if (importedRef != null) return importedRef;

    return varExpr;
}

/////////// SECOND PASS

Expression ExpressionResolver_SecondPass_BaseCtorReference(Resolver resolver, Expression baseCtor) {
    baseCtor.entityPtr = ((ClassEntity)resolver.activeEntity.nestParent.specificData).baseClassEntity.baseData;
    return baseCtor;
}

Expression ExpressionResolver_SecondPass_BitwiseNot(Resolver resolver, Expression bwn) {
    bwn.root = resolver.ResolveExpressionSecondPass(resolver, bwn.root);

    if (IsExpressionConstant(bwn.root)) {
        if (bwn.root.type != ExpressionType.INTEGER_CONST) {
            Errors_Throw(bwn.firstToken, "Bitwise-NOT operator can only be applied on integers.");
        }
        return Expression_createIntegerConstant(bwn.firstToken, -bwn.root.intVal - 1);
    }
    return bwn;
}

Expression ExpressionResolver_SecondPass_BoolConst(Resolver resolver, Expression bc) {
    return bc;
}

Expression ExpressionResolver_SecondPass_BoolNot(Resolver resolver, Expression bn) {
    bn.root = resolver.ResolveExpressionSecondPass(resolver, bn.root);

    if (IsExpressionConstant(bn.root)) {
        if (bn.root.type != ExpressionType.BOOLEAN_NOT) {
            Errors_Throw(bn.firstToken, "Boolean-NOT operator can only be applied to booleans.");
        }
        return Expression_createBoolConstant(bn.firstToken, !bn.root.boolVal);
    }

    return bn;
}

Expression ExpressionResolver_SecondPass_ClassReference(Resolver resolver, Expression classRef) {
    if (!classRef.boolVal) {
        Errors_Throw(classRef.firstToken, "A class reference must have a field or method referenced from it.");
    }
    return classRef;
}

Expression ExpressionResolver_SecondPass_ConstructorReference(Resolver resolver, Expression ctorRef, bool isExpected) {
    if (isExpected) {
        ctorRef.root.boolVal = true;
        ctorRef.root = resolver.ResolveExpressionSecondPass(resolver, ctorRef.root);
        if (ctorRef.root.type != ExpressionType.CLASS_REFERENCE) {
            Errors_Throw(ctorRef.root.firstToken, "This is not a valid class definition.");
        }
        ctorRef.entityPtr = ctorRef.root.entityPtr;
        ctorRef.root = null;
        return ctorRef;
    }

    Errors_Throw(ctorRef.firstToken, "A constructor must be immediately invoked.");
    return ctorRef;
}

Expression ExpressionResolver_SecondPass_DictionaryDefinition(Resolver resolver, Expression dictDef) {
    int length = dictDef.keys.Size();
    Dictionary<string, bool> strCollide = new Dictionary<string, bool>();
    Dictionary<int, bool> intCollide = new Dictionary<int, bool>();
    for (int i = 0; i < length; i += 1) {
        Expression key = resolver.ResolveExpressionSecondPass(resolver, dictDef.keys[i]);
        bool isMixed = false;
        bool isCollide = false;
        if (key.type == ExpressionType.INTEGER_CONST) {
            isMixed = strCollide.Size() > 0;
            isCollide = intCollide.Contains(key.intVal);
            intCollide[key.intVal] = true;
        } else if (key.type == ExpressionType.STRING_CONST) {
            isMixed = intCollide.Size() > 0;
            isCollide = strCollide.Contains(key.strVal);
            strCollide[key.strVal] = true;
        } else {
            Errors_Throw(key.firstToken, "This type of expression cannot be used as a dictionary key. Dictionary keys must be constant integer or string expressions.");
        }

        if (isMixed) {
            Errors_Throw(key.firstToken, "Dictionary cannot contain mixed types for keys.");
        }

        if (isCollide) {
            Errors_Throw(key.firstToken, "There are multiple keys with this same value.");
        }

        dictDef.keys[i] = key;
        dictDef.values[i] = resolver.ResolveExpressionSecondPass(resolver, dictDef.values[i]);
    }
    return dictDef;
}

Expression ExpressionResolver_SecondPass_DotField(Resolver resolver, Expression df) {
    // This is the only way to refer to a class reference.
    if (df.root.type == ExpressionType.CLASS_REFERENCE) df.root.boolVal = true;

    df.root = resolver.ResolveExpressionSecondPass(resolver, df.root);
    switch (df.root.type) {
        case ExpressionType.STRING_CONST:
            if (df.strVal == "length") {
                return Expression_createIntegerConstant(df.firstToken, df.root.strVal.Size());
            }
            break;

        case ExpressionType.THIS:
        case ExpressionType.BASE:
            // TODO: check to see if field exists.
            // For now, just trust it at runtime as if it were a blind variable.
            break;

        case ExpressionType.CLASS_REFERENCE:
            ClassEntity classDef = (ClassEntity)df.root.entityPtr.specificData;
            AbstractEntity member = null;
            if (classDef.classMembers.Contains(df.strVal)) {
                member = classDef.classMembers[df.strVal];
                if (!member.isStatic) {
                    Errors_Throw(df.opToken, classDef.baseData.fqName + "." + df.strVal + " is not static.");
                }
            } else {
                Errors_Throw(df.opToken, "The class " + classDef.baseData.fqName + " does not have a member named '." + df.strVal + "'.");
            }
            break;
    }

    return df;
}

Expression ExpressionResolver_SecondPass_EnumConstant(Resolver resolver, Expression enumConst) {
    return enumConst;
}

Expression ExpressionResolver_SecondPass_ExtensionInvocation(Resolver resolver, Expression expr) {
    ExpressionResolver_ResolveExpressionArraySecondPass(resolver, expr.args);
    int argc = -1;
    if (SpecialActionUtil_IsSpecialActionAndNotExtension(resolver.staticCtx.specialActionUtil, expr.strVal)) {
        argc = SpecialActionUtil_GetSpecialActionArgc(resolver.staticCtx.specialActionUtil, expr.strVal);
    } else {
        string name = expr.strVal;
        if (name == "delay_invoke") argc = 2;
        else if (name == "io_stdout") argc = 1;
        else if (name == "sleep") argc = 1;
        else if (Resolver_isValidRegisteredExtension(resolver, expr.strVal)) {
            return expr;
        } else {
            Errors_Throw(expr.firstToken, "Extension is not registered: " + expr.strVal);
        }
    }

    if (argc != -1 && expr.args.Size() != argc) {
        Errors_Throw(expr.firstToken, "Incorrect number of arguments to extension");
    }

    return expr;
}

Expression ExpressionResolver_SecondPass_FloatConstant(Resolver resolver, Expression floatConst) {
    return floatConst;
}

Expression ExpressionResolver_SecondPass_FunctionInvocation(Resolver resolver, Expression funcInvoke) {
    if (funcInvoke.root.type == ExpressionType.CONSTRUCTOR_REFERENCE) {
        Expression ctorRef = ExpressionResolver_SecondPass_ConstructorReference(resolver, funcInvoke.root, true);
        if (ctorRef.type != ExpressionType.CONSTRUCTOR_REFERENCE) {
            fail(""); // this shouldn't happen. 
        }

        ExpressionResolver_ResolveExpressionArraySecondPass(resolver, funcInvoke.args);

        return Expression_createConstructorInvocation(
            funcInvoke.firstToken, 
            (AbstractEntity)ctorRef.entityPtr, 
            funcInvoke.opToken, 
            funcInvoke.args);
    }

    funcInvoke.root = resolver.ResolveExpressionSecondPass(resolver, funcInvoke.root);

    switch (funcInvoke.root.type) {
        case ExpressionType.VARIABLE:
        case ExpressionType.BASE:
        case ExpressionType.FUNCTION_REFERENCE:
        case ExpressionType.DOT_FIELD:
        case ExpressionType.BASE_CTOR_REFERENCE:
        case ExpressionType.INDEX:
            break;

        default:
            Errors_Throw(funcInvoke.opToken, "Cannot invoke this type of expression like a function.");
            break;
    }

    ExpressionResolver_ResolveExpressionArraySecondPass(resolver, funcInvoke.args);

    return funcInvoke;
}

Expression ExpressionResolver_SecondPass_FunctionReference(Resolver resolver, Expression funcRef) {
    return funcRef;
}

Expression ExpressionResolver_SecondPass_ImportReference(Resolver resolver, Expression importRef) {
    Errors_Throw(
        importRef.firstToken,
        "An import reference cannot be passed as a reference. You must reference the imported entity directly.");
    return null;
}

Expression ExpressionResolver_SecondPass_Index(Resolver resolver, Expression indexExpr) {
    indexExpr.root = resolver.ResolveExpressionSecondPass(resolver, indexExpr.root);
    indexExpr.right = resolver.ResolveExpressionSecondPass(resolver, indexExpr.right);
    return indexExpr;
}

Expression ExpressionResolver_SecondPass_InlineIncrement(Resolver resolver, Expression inlineIncr) {
    inlineIncr.root = resolver.ResolveExpressionSecondPass(resolver, inlineIncr.root);
    switch (inlineIncr.root.type) {
        case ExpressionType.VARIABLE:
        case ExpressionType.INDEX:
        case ExpressionType.DOT_FIELD:
            // these are fine
            break;

        default:
            Errors_Throw(inlineIncr.opToken, "Cannot use the '" + inlineIncr.opToken.Value + "' operator on this type of expression.");
            break;
    }
    return inlineIncr;
}

Expression ExpressionResolver_SecondPass_IntegerConstant(Resolver resolver, Expression intConst) {
    return intConst;
}

Expression ExpressionResolver_SecondPass_Lambda(Resolver resolver, Expression lambda) {
    return lambda;
}

Expression ExpressionResolver_SecondPass_ListDefinition(Resolver resolver, Expression listDef) {
    for (int i = 0; i < listDef.values.Size(); i += 1) {
        listDef.values[i] = resolver.ResolveExpressionSecondPass(resolver, listDef.values[i]);
    }
    return listDef;
}

Expression ExpressionResolver_SecondPass_NamespaceReference(Resolver resolver, Expression nsRef) {
    Errors_Throw(nsRef.firstToken, "You cannot use a namespace reference like this.");
    return null;
}

Expression ExpressionResolver_SecondPass_NegativeSign(Resolver resolver, Expression negSign) {
    Expression root = resolver.ResolveExpressionSecondPass(resolver, negSign.root);
    negSign.root = root;
    if (IsExpressionNumericConstant(root)) {
        switch (root.type) {
            case ExpressionType.INTEGER_CONST:
                root.intVal *= -1;
                break;
            case ExpressionType.FLOAT_CONST:
                root.floatVal *= -1;
                break;
            case ExpressionType.ENUM_CONST:
                root = Expression_createIntegerConstant(root.firstToken, -root.intVal);
                break;
            default:
                fail("Not implemented");
                break;
        }
        return root;
    }

    return negSign;
}

Expression ExpressionResolver_SecondPass_NullConstant(Resolver resolver, Expression nullConst) {
    return nullConst;
}
    
Expression ExpressionResolver_SecondPass_Slice(Resolver resolver, Expression slice) {
    slice.root = resolver.ResolveExpressionSecondPass(resolver, slice.root);
    for (int i = 0; i < 3; i++) {
        if (slice.args[i] != null) {
            Expression expr = resolver.ResolveExpressionSecondPass(resolver, slice.args[i]);
            slice.args[i] = expr;
            if (IsExpressionConstant(expr)) {
                if (expr.type != ExpressionType.INTEGER_CONST && expr.type != ExpressionType.ENUM_CONST) {
                    Errors_Throw(expr.firstToken, "Only integers may be used in a slice expression.");
                }
            }
        }
    }

    return slice;
}

Expression ExpressionResolver_SecondPass_StringConstant(Resolver resolver, Expression strConst) {
    return strConst;
}

Expression ExpressionResolver_SecondPass_Ternary(Resolver resolver, Expression ternary) {
    ternary.root = resolver.ResolveExpressionSecondPass(resolver, ternary.root);
    ternary.left = resolver.ResolveExpressionSecondPass(resolver, ternary.left);
    ternary.right = resolver.ResolveExpressionSecondPass(resolver, ternary.right);

    if (IsExpressionConstant(ternary.root)) {
        if (ternary.root.type != ExpressionType.BOOL_CONST) {
            Errors_Throw(ternary.root.firstToken, "Only booleans can be used as ternary conditions.");
        }

        if (ternary.root.boolVal) return ternary.left;
        return ternary.right;
    }

    return ternary;
}

Expression ExpressionResolver_SecondPass_ThisConstant(Resolver resolver, Expression thisExpr) {
    if (resolver.activeEntity.nestParent == null) {
        fail("not implemented");
    }
    return thisExpr;
}

Expression ExpressionResolver_SecondPass_TypeOf(Resolver resolver, Expression typeofExpr) {
    typeofExpr.root = resolver.ResolveExpressionSecondPass(resolver, typeofExpr.root);
    string stringConst = null;
    switch (typeofExpr.root.type) {
        case ExpressionType.INTEGER_CONST: stringConst = "int"; break;
        case ExpressionType.FLOAT_CONST: stringConst = "float"; break;
        case ExpressionType.NULL_CONST: stringConst = "null"; break;
        case ExpressionType.BOOL_CONST: stringConst = "bool"; break;
        case ExpressionType.STRING_CONST: stringConst = "string"; break;
        case ExpressionType.FUNCTION_REFERENCE: stringConst = "function"; break;

        case ExpressionType.LIST_DEFINITION:
            if (typeofExpr.root.values.Size() == 0) stringConst = "list";
            break;

        case ExpressionType.DICTIONARY_DEFINITION:
            if (typeofExpr.root.keys.Size() == 0) stringConst = "dict";
            break;
    }

    if (stringConst != null) {
        return Expression_createStringConstant(typeofExpr.firstToken, stringConst);
    }

    return typeofExpr;
}

Expression ExpressionResolver_SecondPass_Variable(Resolver resolver, Expression varExpr) {
    if (varExpr.strVal == "print") fail(""); // should not happen.
    if (((FunctionEntity)resolver.activeEntity.specificData).variableScope.Contains(varExpr.strVal)) return varExpr;

    // TODO: come up with a list of suggestions.
    Errors_Throw(varExpr.firstToken, "There is no variable by the name of '" + varExpr.strVal + "'.");
    return null;
}

////////// HELPER METHODS

Expression ExpressionResolver_IntegerRequired(Resolver resolver, Expression expr) {
    switch (expr.type) {
        case ExpressionType.ENUM_CONST:
            EnumEntity enumParent = (EnumEntity)expr.entityPtr.specificData;
            string enumMem = expr.strVal;
            for (int i = 0; i < enumParent.memberValues.Size(); i += 1) {
                if (enumMem == enumParent.memberNameTokens[i].Value) {
                    Expression val = enumParent.memberValues[i];
                    if (val.type != ExpressionType.INTEGER_CONST) {
                        fail(""); // invalid operation
                    }
                    return val;
                }
            }
            Errors_Throw(expr.firstToken, "The enum '" + enumParent.baseData.fqName + "' does not have a member named '" + enumMem + "'.");
            break;

        case ExpressionType.BOOL_CONST:
        case ExpressionType.FLOAT_CONST:
        case ExpressionType.STRING_CONST:
        case ExpressionType.BOOLEAN_NOT:
            Errors_Throw(expr.firstToken, "An integer is expected here.");
            break;
    }

    return expr;
}

AbstractEntity ExpressionResolver_FindLocallyReferencedEntity(StaticContext staticCtx, Dictionary<string, AbstractEntity> lookup, string name) {
    if (lookup.Contains(name)) {
        return lookup[name];
    }

    if (lookup.Contains("..")) {
        Dictionary<string, AbstractEntity> prevLevelLookup = Entity_getMemberLookup(staticCtx, lookup[".."]);
        return ExpressionResolver_FindLocallyReferencedEntity(staticCtx, prevLevelLookup, name);
    }

    return null;
}

Expression ExpressionResolver_WrapEntityIntoReferenceExpression(Resolver resolver, Token token, AbstractEntity entity) {
    switch (entity.type) {
        case EntityType.FUNCTION:
            return Expression_createFunctionReference(token, entity.simpleName, entity);

        case EntityType.CLASS:
            return Expression_createClassReference(token, entity);

        case EntityType.CONST:
            return Expression_cloneWithNewToken(token, ((ConstEntity)entity.specificData).constValue);

        case EntityType.ENUM:
            return Expression_createEnumReference(token, entity);

        case EntityType.NAMESPACE:
            return Expression_createNamespaceReference(token, entity);
    }

    Errors_Throw(token, "Not implemented!");
    return null;
}
