struct CompilerContext {
    StaticContext staticCtx;
    string rootId;
    Dictionary<string, List<string>> depIdsByModuleId;
    Dictionary<string, List<FileContext>> filesByModuleId;
    List<string> finalCompilationOrder;
    Dictionary<string, bool> unfulfilledDependencies;
    Dictionary<string, CompiledModule> compiledModulesById;
    string extensionVersionId;
    string flavorId;
    List<string> extensionNames;
}

CompilerContext CompilerContext_new(string rootId, string flavorId, string extensionVersionId, Array<string> extensionNames) {

    CompilerContext ctx = new CompilerContext(
        StaticContext_new(),
        rootId,
        new Dictionary<string, List<string>>(), // depIdsByModuleId
        new Dictionary<string, List<FileContext>>(), // filesByModuleId
        null, // finalCompilationOrder
        new Dictionary<string, bool>(), // unfulfilledDependencies
        null, // compiledModulesById
        extensionVersionId,
        flavorId,
        new List<string>() // extensionNames
    );

    for (int i = 0; i < extensionNames.size(); i += 1) {
        ctx.extensionNames.add(extensionNames[i]);
    }

    ctx.unfulfilledDependencies[rootId] = true;

    Dictionary<string, string> builtinFiles = new Dictionary<string, string>();
    builtinFiles["builtins.script"] = GetSourceForBuiltinModule("builtins");

    PUBLIC_SupplyFilesForModule(ctx, "{BUILTIN}", builtinFiles, true, true);

    return ctx;
}

void PUBLIC_SupplyFilesForModule(
    object compObj,
    string moduleId,
    Dictionary<string, string> fileLookup,
    bool isCoreBuiltin,
    bool isBuiltInLib)
{
    int i = 0;
    int j = 0;

    CompilerContext compiler = (CompilerContext) compObj;

    compiler.depIdsByModuleId[moduleId] = new List<string>();

    List<FileContext> files = new List<FileContext>();
    Dictionary<string, ImportStatement> imports = new Dictionary<string, ImportStatement>();
    Array<string> fileNamesOrdered = Sorting.getLexicalSortedCopy(fileLookup.keys());
    for (i = 0; i < fileNamesOrdered.size(); i += 1) {
        string path = fileNamesOrdered[i];
        FileContext fileCtx = FileContext_new(compiler.staticCtx, path, fileLookup[path]);
        fileCtx.isCoreBuiltin = isCoreBuiltin;
        fileCtx.isBuiltInLib = isBuiltInLib;
        files.add(fileCtx);
        fileCtx.imports = ImportParser_AdvanceThroughImports(fileCtx.tokens, isCoreBuiltin);
        FileContext_initializeImportLookup(fileCtx);
        for (j = 0; j < fileCtx.imports.size(); j += 1) {
            ImportStatement impStmnt = fileCtx.imports[j];
            imports[impStmnt.flatName] = impStmnt;
        }
    }
    compiler.filesByModuleId[moduleId] = files;

    if (compiler.unfulfilledDependencies.contains(moduleId)) {
        compiler.unfulfilledDependencies.remove(moduleId);
    }

    List<string> allDeps = new List<string>();
    Array<string> importedIds = imports.keys();
    for (i = 0; i < importedIds.size(); i += 1) allDeps.add(importedIds[i]);

    compiler.depIdsByModuleId[moduleId] = allDeps;
    for (i = 0; i < allDeps.size(); i += 1) {
        string depId = allDeps[i];
        if (!compiler.filesByModuleId.contains(depId)) {
            compiler.unfulfilledDependencies[depId] = true;
        }
    }
}

void PUBLIC_EnsureDependenciesFulfilled(object compObj) {
    CompilerContext compiler = (CompilerContext) compObj;
    if (compiler.unfulfilledDependencies.size() > 0) {
        // TODO: Is this user-facing?
        fail("Not all dependencies are fulfilled.");
    }
}

string PUBLIC_GetNextRequiredModuleId(object compObj) {
    CompilerContext compiler = (CompilerContext)compObj;
    while (true) {
        if (compiler.unfulfilledDependencies.size() == 0) return null;

        Array<string> unfulfilledDependencies = Sorting.getLexicalSortedCopy(compiler.unfulfilledDependencies.keys());
        string nextKey = unfulfilledDependencies[0];

        if (!IsBuiltInModule(nextKey)) {
            return nextKey;
        }

        Dictionary<string, string> builtinFiles = new Dictionary<string, string>();
        builtinFiles[nextKey + ".script"] = GetSourceForBuiltinModule(nextKey);

        PUBLIC_SupplyFilesForModule(
            compiler,
            nextKey,
            builtinFiles,
            false,
            true);
    }
}

Array<string> CompilerContext_CalculateCompilationOrder(CompilerContext compiler) {
    Dictionary<string, int> recurseState = new Dictionary<string, int>();
    List<string> order = new List<string>();
    List<string> queue = new List<string>();
    queue.add(compiler.rootId);

    while (queue.size() > 0) {
        int last = queue.size() - 1;
        string currentId = queue[last];
        queue.removeAt(last);
        int currentRecurseState = 0;
        if (recurseState.contains(currentId)) currentRecurseState = recurseState[currentId];

        if (currentRecurseState == 2) {
            // It's already handled. Move on
        } else {
            List<string> deps = compiler.depIdsByModuleId[currentId];
            List<string> newDeps = new List<string>();


            for (int i = 0; i < deps.size(); i += 1) {
                string depId = deps[i];
                if (recurseState.contains(depId)) {
                    if (recurseState[depId] == 2) {
                        // already added, just ignore it.
                    } else if (recurseState[depId] == 1) {
                        // in the process of adding. We have a dependency cycle!
                        // TODO: this is user-facing
                        fail("There is a cyclical dependency involving " + depId + " and " + currentId);
                    }
                } else {
                    newDeps.add(depId);
                }
            }

            if (newDeps.size() == 0) {
                recurseState[currentId] = 2;
                order.add(currentId);
            } else {
                recurseState[currentId] = 1;
                queue.add(currentId);
                for (i = 0; i < newDeps.size(); i += 1) {
                    queue.add(newDeps[i]);
                }
            }
        }
    }

    return order.toArray();
}

Array<int> PUBLIC_CompleteCompilation(object compObj) {
    CompilerContext compiler = (CompilerContext) compObj;

    Array<string> moduleCompilationOrder = CompilerContext_CalculateCompilationOrder(compiler);

    compiler.compiledModulesById = new Dictionary<string, CompiledModule>();

    for (int i = 0; i < moduleCompilationOrder.size(); i += 1) {
        string moduleId = moduleCompilationOrder[i];
        CompiledModule module = CompilerContext_CompileModule(compiler, moduleId);
        compiler.compiledModulesById[moduleId] = module;
    }

    Array<CompiledModule> modules = compiler.compiledModulesById.values();
    CompilationBundle bundle = bundleCompilation(compiler.staticCtx, compiler.rootId, modules);

    return ExportUtil_exportBundle(compiler.flavorId, compiler.extensionVersionId, bundle);
}

CompiledModule CompilerContext_CompileModule(CompilerContext compiler, string moduleId) {
    int i = 0;
    List<FileContext> files = compiler.filesByModuleId[moduleId];

    Dictionary<string, AbstractEntity> rootEntities = new Dictionary<string, AbstractEntity>();
    Dictionary<string, string> sourceCode = new Dictionary<string, string>();
    for (i = 0; i < files.size(); i += 1) {
        FileContext file = files[i];
        sourceCode[file.path] = file.content;
        for (int j = 0; j < file.imports.size(); j += 1) {
            ImportStatement importStatement = file.imports[j];
            importStatement.compiledModuleRef = compiler.compiledModulesById[importStatement.flatName];
        }
        ParseOutEntities(compiler, file, rootEntities, null, "");
        Token danglingToken = Tokens_peek(file.tokens);
        if (danglingToken != null) {
            Errors_Throw(danglingToken, "Unexpected token: '" + danglingToken.Value + "'. You might have too many close parentheses in this file.");
        }
    }

    Resolver resolverCtx = Resolver_new(compiler.staticCtx, rootEntities, compiler.extensionNames);
    Resolve(resolverCtx);

    CompiledModule m = CompiledModule_new(moduleId);
    m.codeFiles = sourceCode;
    CompiledModule_AddLambdas(m, resolverCtx.lambdas);
    CompiledModule_InitializeLookups(m, resolverCtx.nestedEntities, resolverCtx.flattenedEntities);
    for (i = 0; i < files.size(); i += 1) {
        FileContext file = files[i];
        file.compiledModule = m;
    }

    return m;
}
