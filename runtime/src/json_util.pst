Value json_util_parse(ExecutionContext ec, string rawValue, Array<int> errOut) {
    errOut[0] = 0;

    List<object> bufferOut = new List<object>();
    object[] args = new object[2];
    args[0] = rawValue;
    args[1] = bufferOut;
    Pastel.invokeExtension("jsonParse", args);
    if (!(bool) bufferOut[0]) {
        errOut[0] = 1;
        errOut[1] = (int) bufferOut[1];
        errOut[2] = (int) bufferOut[2];
        return ec.globalValues.nullValue;
    }
    int[] index = new int[1];
    index[0] = 1;
    return json_util_parseFromBuf(ec, index, bufferOut);
}

Value json_util_parseFromBuf(ExecutionContext ec, int[] index, List<object> buf) {
    int i = index[0];
    switch ((int) buf[i]) {
        case 0: // null
            index[0] = i + 1;
            return ec.globalValues.nullValue;
        case 1: // bool
            index[0] = i + 2;
            if ((bool)buf[i + 1]) return ec.globalValues.trueValue;
            return ec.globalValues.falseValue;
        case 2: // integer
            index[0] = i + 2;
            return buildInteger(ec.globalValues, (int) buf[i + 1]);
        case 3: // float
            index[0] = i + 2;
            return buildFloat((double) buf[i + 1]);
        case 4: // string
            index[0] = i + 2;
            return buildString(ec.globalValues, (string) buf[i + 1], false);
        case 5: // list
            int len = (int) buf[i + 1];
            index[0] = i + 2;
            Value[] listItems = new Value[len];
            for (int j = 0; j < len; j += 1) {
                listItems[j] = json_util_parseFromBuf(ec, index, buf);
            }
            return buildList(ec, listItems, false, len);
        case 6: // dictionary
            int sz = (int) buf[i + 1];
            index[0] = i + 2;
            Value[] keys = new Value[sz];
            Value[] values = new Value[sz];
            for (int k = 0; k < sz; k += 1) {
                // TODO: create a lookup of string keys to Values scoped to the entire parse call
                // as repeating keys are very likely.
                keys[k] = buildString(ec.globalValues, (string) buf[index[0]], false);
                index[0] = index[0] + 1;
                values[k] = json_util_parseFromBuf(ec, index, buf);
            }
            return buildStringDictionary(ec, keys, values);
    }
    fail("");
    return null;
}

string json_util_serialize(GlobalValues g, Value root, bool useIndent, ListImpl errOut) {
    List<string> stringBuilder = new List<string>();
    List<int> objectIds = new List<int>();
    List<string> tabs = new List<string>();
    tabs.add("");
    string err = json_util_serialize_impl_any(root, useIndent, 0, tabs, stringBuilder, new List<int>());
    if (err != null) {
        List_set(errOut, 0, buildString(g, err, false));
        return "";
    }
    return stringBuilder.join("");
}

bool json_util_cycle_check_push(List<int> refIds, int refId) {
    int sz = refIds.size();
    for (int i = 0; i < sz; i += 1) {
        if (refIds[i] == refId) return true;
    }
    refIds.add(refId);
    return false;
}

string json_util_serialize_dict(
    Value value,
    bool useIndent,
    int currentDepth,
    List<string> tabs,
    List<string> sb,
    List<int> refCycleCheck) {

    DictImpl dict = (DictImpl) value.internalValue;
    int sz = dict.size;
    if (sz == 0) {
        sb.add("{}");
        return null;
    }
    if (json_util_cycle_check_push(refCycleCheck, dict.id)) return "JSON serialization encountered a reference cycle.";
    Value[] keys = dict.keys;
    Value[] values = dict.values;

    int newDepth = currentDepth + 1;
    if (useIndent) tabs.add(tabs[tabs.size() - 1] + "\t");

    sb.add("{" /* } */);
    if (useIndent) sb.add("\n");

    for (int i = 0; i < sz; i += 1) {
        Value k = keys[i];
        Value v = values[i];
        if (useIndent) sb.add(tabs[newDepth]);

        json_util_serialize_impl_any(k, useIndent, newDepth, tabs, sb, refCycleCheck);

        if (useIndent) sb.add(": ");
        else sb.add(":");

        string err = json_util_serialize_impl_any(v, useIndent, newDepth, tabs, sb, refCycleCheck);
        if (err != null) return err;

        if (i < sz - 1) sb.add(",");

        if (useIndent) sb.add("\n");
    }

    if (useIndent) sb.add(tabs[currentDepth]);
    sb.add(/* { */ "}");

    refCycleCheck.pop();
    return null;
}

string json_util_serialize_list(
    Value value,
    bool useIndent,
    int currentDepth,
    List<string> tabs,
    List<string> sb,
    List<int> refCycleCheck) {

    ListImpl list = (ListImpl) value.internalValue;
    int sz = list.length;
    if (sz == 0) {
        sb.add("[]");
        return null;
    }
    if (json_util_cycle_check_push(refCycleCheck, list.id)) return "JSON serialization encountered a reference cycle.";
    int newDepth = currentDepth + 1;
    if (useIndent) tabs.add(tabs[tabs.size() - 1] + "\t");

    sb.add("[" /* ] */);
    if (useIndent) sb.add("\n");

    for (int i = 0; i < sz; i += 1) {
        Value item = list.items[i];

        if (useIndent) sb.add(tabs[newDepth]);

        string err = json_util_serialize_impl_any(item, useIndent, newDepth, tabs, sb, refCycleCheck);
        if (err != null) return err;

        if (i < sz - 1) sb.add(",");

        if (useIndent) sb.add("\n");
    }

    if (useIndent) sb.add(tabs[currentDepth]);
    sb.add(/* [ */ "]");

    refCycleCheck.pop();
    return null;
}

string json_util_serialize_impl_any(
    Value value,
    bool useIndent,
    int currentDepth,
    List<string> tabs,
    List<string> sb,
    List<int> refCycleCheck) {

    switch (value.type) {
        case Type.DICTIONARY: return json_util_serialize_dict(value, useIndent, currentDepth, tabs, sb, refCycleCheck);
        case Type.LIST: return json_util_serialize_list(value, useIndent, currentDepth, tabs, sb, refCycleCheck);

        case Type.NULL:
            sb.add("null");
            return null;

        case Type.BOOLEAN:
            if ((bool)value.internalValue) {
                sb.add("true");
            } else {
                sb.add("false");
            }
            return null;

        case Type.INTEGER:
            // TODO: test for large integers.
            sb.add(Convert.intToString((int) value.internalValue));
            return null;

        case Type.FLOAT:
            sb.add(Convert.floatToString((double) value.internalValue));
            return null;

        case Type.STRING:
            StringImpl strImpl = (StringImpl) value.internalValue;
            if (strImpl.nativeStr == null) stringFlatten(strImpl);
            sb.add(Json.serializeString(strImpl.nativeStr));
            return null;

        default:
            return "Invalid JSON serialization type";
    }
}
